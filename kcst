#!/usr/bin/php
<?php $conf['kcst_version']="0.9.5";

# kcst - KotCzarny's slackware tool
# Copyright (C) ariel/KotCzarny 2018
# All rights reserved.
# This project is distributed under GPLv3 license.

#!/1/php4static
#!/1/_src/php/php-4.4.9/sapi/cli/php

# REQUIREMENTS:
# - php (cli, 4+)
# - wget
# - bzip2 (for "sf": MANIFEST.bz2)
# - find, grep (for some tools)
# PKG TOOLS:
# - s/sf/g/r/u/d/l - package manager
# - news - get and display ChangeLog.txt
# - fixlibs - find and install packages for missing library dependencies
# - sbs/sbu/sbd/sbb/sbg - slackbuilds search/update/download/build/get
# kc's TOOLS:
# - slist/start/stop/restart/reload/graceful - /etc/rc.d/rc.* service controller
# - rnm - regexp based batch renamer
# - gf - grep-find
# - cf - count files
# - ru - cruft cleaner (use only after checking what it does!)
# - mconf/mmake/mpkg/mhelp - source to pkg helpers (if one is too lazy to write .slackbuild)
# BUGS/CAVEATS:
# - doesnt check for dependencies in install/upgrade
# - interrupted install/upgrade/remove might leave cruft, add a tool for that
# DONE:
# + use config file instead of hardcoding in script
# + changelog.txt 'news' command
# + check downloads with md5
# + sbd: get from slackware.uk/sbosrcarch if original download fails
# TODO/IDEAS:
# - 64bit support (downloads)
# - sources/(re)building
# - workarounds for building older software: -std=gnu89
# - check if packages are ok when $cwd contains no version
# - GUI
# - get rid of run() where possible
# - replace rm with code
# - replace `` with code or $()
# - compress manpages with xz?
# - compress MANIFEST with gz

### DEFAULT CONFIG ###
#
# Note: kcst.conf (from /etc or ~ or .) will override any of config settings
#

#$conf['release']='slackware-current';
$conf['release']='slackware-14.2';
#$conf['release']='slackware-14.0';
#$conf['release']='slackware64-current';

# download and temporary files location
$conf['dl_path']="/tmp/kcst-tmp";

# slackbuilds config
$conf['sb_release']="14.2";
$conf['sb_path']=$conf['dl_path']."/sb";
$conf['sb_TAG']=""; # will get replaced by _hostname if empty

# clear some cruft after pkg install. enable only after you check what remove_unneeded() does.
$conf['remove_unneeded']=!true;

# upgrade only when major version changes?
$conf['only_major_diff_in_upgrade']=!true;

# throttle download?
$conf['rate_limit']=""; #$conf['ratelimit']="--limit-rate=910k";
### DEFAULT CONFIG END ###

### POSTCONFIG ###
get_config();

$conf['sb_base']="http://slackbuilds.org/slackbuilds/".$conf['sb_release'];

# wget cmdline
$conf['wget']="wget -nv --show-progress --progress=bar -o- -nc -c ${conf['rate_limit']} -P \"${conf['dl_path']}\"";
# for old system where you can't update wget/certs any other way
# and https is not working:
#$conf['wget'].=" --no-check-certificate";

$conf['bases']=array( /* default: */ 0=>1,
 1=>"http://mirrors.slackware.com/slackware/${conf['release']}/slackware/",
 2=>"ftp://ftp.slackware.com/pub/slackware/${conf['release']}/slackware",
 3=>"ftp://ftp.man.poznan.pl/pub/linux/slackware/${conf['release']}/slackware",
 4=>"http://slackware.cs.utah.edu/${conf['release']}/slackware",
 5=>"http://slackware.mirrors.pair.com/${conf['release']}/slackware",
 6=>"ftp://ftp.funet.fi/pub/mirrors/ftp.slackware.com/pub/${conf['release']}/slackware",
 7=>"http://ftp.gwdg.de/pub/linux/slackware/${conf['release']}/slackware",
 8=>"http://slackware.osuosl.org/${conf['release']}/slackware",
 9=>"http://mirror.switch.ch/ftp/mirror/slackware/${conf['release']}/slackware",
);

$conf['base_installeds']=array( /* default: */ 0=>1,
 1=>"/var/log/packages",
 2=>"/mnt/tt/var/log/packages",
);

if(!is_dir($conf['dl_path'])) mkdir($conf['dl_path'], 0700, 1);
if(!is_dir($conf['sb_path'])) mkdir($conf['sb_path'], 0700, 1);
if($conf['sb_TAG']=='') {
 $conf['sb_TAG']="_".preg_replace("@[^a-zA-Z0-9]@", "", @file_get_contents("/proc/sys/kernel/hostname"));
 if($conf['sb_TAG']=='_') $conf['sb_TAG']='';
}

$conf['base']=$conf['bases'][$conf['bases'][0]];  $conf['base1']=$conf['base'];
$conf['base_installed']=$conf['base_installeds'][$conf['base_installeds'][0]];
### POSTCONFIG END ###

### MAIN ###
if(!empty($_GET)) { httpd_way(); return; }

$p=@$argv[1]; unset($argv[0]); unset($argv[1]);

if($p==''||$p=="-h"||$p=="--help") { show_help(); return; }
if($p=="s" || $p=="search") { pkg_search(@$argv[2]); return; }
if($p=="g" || $p=="get") { check_root(); pkg_get(join(" ",$argv)); return; }
if($p=="d" || $p=="download") { pkg_download(join(" ",$argv)); return; }
if($p=="r" || $p=="remove") { check_root(); pkg_remove(join(" ",$argv)); return; }
if($p=="u" || $p=="upgrade") { check_root(); pkg_upgrade(@$argv[2]); return; }
if($p=="l" || $p=="list") { pkg_list(@$argv[2]); return; }
if($p=="upd" || $p=="update") { check_root(); update_file("PACKAGES.TXT",0,1); return; }
if($p=="sf") { pkg_search_file(@$argv[2],1); return; }
if($p=="news") { pkg_news(); return; }
if($p=="fixlibs") { check_root(); pkg_fixlibs(join(" ",$argv)); return; }
if($p=="sbs") { sb_search(join(" ",$argv)); return; }
if($p=="sbu") { sb_update(); return; }
if($p=="sbd") { sb_download(join(" ",$argv)); return; }
if($p=="sbb") { sb_build(join(" ",$argv)); return; }
if($p=="sbg") { check_root(); sb_get(join(" ",$argv)); return; }
if(preg_match("@^(slist|stop|start|status|restart|reload|graceful)$@", $p)) { check_root(); svc($p, join(" ",$argv)); return; }
if($p=='ru') { check_root(); $v=@$argv[2]; if($v=="") $v=2; remove_unneeded($v); return; }
if($p=='rnm') { rnm($argv); return; }
if($p=='gf') { grepfind($argv); return; }
if($p=='cf') { count_files($argv); return; }
if($p=="mhelp") { $argv[2]="help"; mconf($argv); return; }
if($p=="mconf") { mconf($argv); return; }
if($p=="mmake") { mmake($argv); return; }
if($p=="mpkg") { mpkg($argv); return; }
show_help(); return;

### MAIN END ###


### FUNCTIONS ###

####################
function show_help() { global $conf;
 print "kcst-${conf['kcst_version']} - KotCzarny's Slackware Tool
Usage: kcst command [args]

Commands:
  u[pgrade] - auto-upgrade pkgs (warning: doesnt check dependencies!)
  update - update PACKAGES.TXT
  g[et] name1 [name2..] - download and install pkgs
  r[emove] name1 [name2..] - remove pkgs
  d[ownload] name1 [name2..] - download pkgs
  l[ist] [string] - list installed pkgs (with optional filtering)
  s[earch] string - search pkgs (string is a regexp)
  sf string - search MANIFEST for file path fragment
  news - get and display changelog.txt
  fixlibs [paths] - try to autoinstall missing libs
  slist|start|stop|restart|reload|graceful string - control system services (/etc/rc.d/rc.string)
  sbu - slackbuilds update list
  sbs string - slackbuilds search
  sbd string - slackbuilds download
  sbb string - slackbuilds download and build
  sbg[et] string - slackbuilds download, build and install
  rnm from to [-d] [-h] [-r] [-w] [-x] - regexp based batch rename, pass -h for help
  cf [path] - count files at path (or . if no path given)
  gf regexp [path1..] - recursively find files/dirs matching regexp in paths (or . if no path given)

release: ${conf['release']}
SBo release: ${conf['sb_release']}
base: ${conf['base']}
download path: ${conf['dl_path']}
SBo tmp path: ${conf['sb_path']}
";
}
#  ru - remove unneeded files (mostly docs and locales, don't use if system is not set to english)
#  mconf [help|mmx|p3|pm|c7] - run ./configure, mmake - run make, mpkg - run makepkg

#####################
function get_config() { global $conf;
 foreach(Array("/etc/kcst.conf","~/kcst.conf","./kcst.conf") as $f)
 {
  if(@filesize($f)>0) foreach(explode("\n",file_get_contents("/etc/kcst.conf")) as $l) {
   if(preg_match("@^([^#][^ =]+)=(.*)$@",$l,$m)) { $conf[$m[1]]=$m[2]; }
  }
 }
}

#####################
function check_root() {
 $uid=-1; if(preg_match("@Uid:\s+(\d+)@", file_get_contents("/proc/self/status"), $m)) $uid=$m[1];
 if($uid!=0) die("this command requires root rights\n");
}

##################
function run($cmd) { $fp=popen($cmd, "r"); if($fp<=0) return -1;
 while(!feof($fp)) print fgets($fp, 32);  return pclose($fp);
}

#######################
function svc($cmd, $sn) {
 if($cmd=='slist') { print `ls -l /etc/rc.d/|grep ^-|grep -v '.new$'`; return; }
 $fn="/etc/rc.d/rc.$sn"; if(file_exists($fn)) { run("$fn $cmd"); return; }
 else { $fn="/etc/rc.d/$sn"; if(file_exists($fn)) { return; run("$fn $cmd"); } }
}

####################
function sb_update() { global $conf;
 $fn0="SLACKBUILDS.TXT.gz"; $link=$conf['sb_base']."/$fn0";
 $fn="${conf['dl_path']}/_$fn0";

 print "sb_update $fn0 .. ";
 run("${conf['wget']} -O \"$fn.tmp\" \"$link\"; if cmp \"$fn.tmp\" \"$fn\"; then rm -v \"$fn.tmp\"; else mv -v \"$fn.tmp\" \"$fn\"; fi ");
 $fs=@filesize($fn);
 if($fs<=1024) { print " failed\n"; return -1; }
 print "got $fs\n"; return $fs;
}

#######################
function sb_get_infos() { global $conf; if(!empty($conf['sb'])) return;
 $fn="${conf['dl_path']}/_SLACKBUILDS.TXT.gz"; if(@filesize($fn)<=1024) { sb_update(); }
 $fp=popen("gzip -dc \"$fn\"","r"); if(!$fp) { print "can't unpack/read $fn\n"; return -1; }
 while(!feof($fp)) { $a=fgets($fp, 512);
  if(preg_match("@^SLACKBUILD NAME: (.+)$@", $a, $m)) { $pn=$m[1]; $conf['sb'][$pn]['NAME']=$pn;
   continue; }
  if(preg_match("@^SLACKBUILD ([A-Za-z0-9 _]+):\s*(.*?)$@", $a, $m)) {
   if($m[1]=="SHORT DESCRIPTION" && preg_match("@\((.+)\)@", $m[2], $m2)) { $m[2]=$m2[1]; }
   $conf['sb'][$pn][$m[1]]=$m[2];
   continue;
  }
 }
 return pclose($fp);
}

#########################
function sb_search($name) { global $conf;
 get_installed(); sb_get_infos(); $found=Array(); print "### ".count($conf['sb'])." sb packages\n";

 print "\n### package names\n";
 $plk=array_keys($conf['sb']); natsort($plk);
 foreach(preg_grep("@$name@i", $plk) as $pn) { $p=$conf['sb'][$pn];
  if(empty($p)) continue;
  if(@$conf['pkgs_installed'][$pn]) $inst='INSTALLED'; else $inst='';
  $REQS=', -'; if(!empty($p['REQUIRES'])) $REQS=", ".$p['REQUIRES'];
  if(preg_match("@^\./([^/]+)@", $p['LOCATION'], $m)) $LOCA=$m[1]; else $LOCA="?";
  print "${p['NAME']} - ${p['SHORT DESCRIPTION']} (${p['VERSION']}, $LOCA$REQS) $inst\n";
  $found[$pn]=1;
 }

 print "\n### package descriptions\n";
 foreach($conf['sb'] as $pn=>$p) {
  if(preg_match("@$name@i", $p['SHORT DESCRIPTION']) && @$found[$pn]!=1)
  {
   if(@$conf['pkgs_installed'][$pn]) $inst='INSTALLED'; else $inst='';
   $REQS=', -'; if(!empty($p['REQUIRES'])) $REQS=", ".$p['REQUIRES'];
   if(preg_match("@^\./([^/]+)@", $p['LOCATION'], $m)) $LOCA=$m[1]; else $LOCA="?";
   print "${p['NAME']} - ${p['SHORT DESCRIPTION']} (${p['VERSION']}, $LOCA$REQS) $inst\n";
   $found[]=$pn;
  }
 }

 print "\n### found ".count($found)." package(s)\n";
}

###########################
function sb_download($name) { global $conf;
 if(empty($name)) { print "empty param\n"; return; }
 sb_get_infos();

 foreach(explode(" ",$name) as $pn) { $p=@$conf['sb'][$pn];
  if(empty($p)) { print "sb package '$pn' not found, skipping\n"; continue; }
  print "getting $pn .. ";
  $path="${conf['sb_path']}/$pn"; $fn="$path.tar.gz";
  $link="${conf['sb_base']}/${p['LOCATION']}.tar.gz";
#  @unlink($fn);
  if(@filesize($fn)>0) print "\n"; else
   run("cd \"${conf['sb_path']}\" && rm -rf \"$pn\" && ${conf['wget']} -O\"$fn\" \"$link\" && tar -xzf \"$fn\" ");

#FIXME: handle MD5SUM_x86_64 and DOWNLOAD_x86_64
  $sums=explode(" ",$p['MD5SUM']);
  foreach(explode(" ", $p['DOWNLOAD']) as $n => $link) if($link!="") {
   $sum=$sums[$n]; $fn0=basename($link); $fn="$path/$fn0"; if(check_md5($fn, $sum)) continue;

   # try getting from .slackbuild specified location
   run("${conf['wget']} -P \"$path\" \"$link\" ");

   if(!check_md5($fn, $sum)) { @unlink($fn);
    print "download failed, trying to get it from slackware.uk/sbosrcarch .. ";
    $link="http://slackware.uk/sbosrcarch/by-md5/${sum[0]}/${sum[1]}/$sum/$fn0";
    run("${conf['wget']} -O\"$fn\" \"$link\" ");
    if(!check_md5($fn, $sum)) { @unlink($fn); die("download failed. please investigate.\n"); }
   }
  }
 }
}

########################
function sb_build($name) { global $conf;
 if(empty($name)) { print "empty param\n"; return; }
 get_installed(); sb_get_infos();

 foreach(explode(" ",$name) as $pn) { $p=@$conf['sb'][$pn];
  if(empty($p)) { print "sb package '$pn' not found, skipping\n"; continue; }

  $reqs=Array(); foreach(explode(" ",$p['REQUIRES']) as $rp) if($rp) {
   if(!@$conf['pkgs_installed'][$rp]) $reqs[]=$rp;
  }
  if(!empty($reqs)) { print "please install required packages first: ".join(" ",$reqs)."\n"; return; }

  $path="${conf['sb_path']}/$pn"; $fn="$path.tar.gz"; $bs="$path/$name.SlackBuild";
  if(!is_file($fn)) sb_download($name);
  if(!is_file($bs)) { print "no \"$name.SlackBuild\", aborting.\n"; if(1)die(); continue; }

  $log="$path/$pn.buildlog";
  run("cd \"$path\" && chmod +x \"$bs\" && TAG=\"${conf['sb_TAG']}\" OUTPUT=\"$path\" \"$bs\" 2>&1 | tee \"$log\" ");
  $a=file_get_contents($log);
  if(!preg_match("@^Slackware package (.+) created\.$@m", $a, $m))
  { print "build failed. please go to \"$path/\" then fix/build manually.\n"; if(1) return -1; else continue; }

  $pkg=$m[1]; $bpkg=basename($pkg);
  print "build OK ($pkg)\n"; rename($pkg,"${conf['sb_path']}/$bpkg");
 }
}

######################
function sb_get($name) { global $conf;
 if(empty($name)) { print "empty param\n"; return; }
 get_installed(); sb_get_infos();

 foreach(explode(" ",$name) as $pn) { $p=@$conf['sb'][$pn];
  if(empty($p)) { print "sb package '$pn' not found, skipping\n"; continue; }
  $path="${conf['sb_path']}/$pn"; $log="$path/$pn.buildlog";

  $a=@file_get_contents($log); if(!preg_match("@^Slackware package (.+) created\.$@m", $a, $m))
  { if(sb_build($pn)<0) die("\n");
   $a=file_get_contents($log); preg_match("@^Slackware package (.+) created\.$@m", $a, $m);
  }
  $bpkg=basename($m[1]); $pkg=$conf['sb_path']."/$bpkg";

  print "installing $bpkg\n";
  $r=run("upgradepkg >>/tmp/kcst.log 2>&1 --install-new \"$pkg\" ");
  if($r!=0) { print ("there was an error ($r), check /tmp/kcst.log for full info, dumping 30 lines:\n\n");
   run("tail -n 30 /tmp/kcst.log"); die(); }

  remove_unneeded(0);
 }
}

###############################################
function update_file($fn0,$dontmangle,$verbose) { global $conf;
 if($dontmangle) $fn="${conf['dl_path']}/$fn0";
 else $fn="${conf['dl_path']}/_$fn0-${conf['release']}";
 $fntmp="$fn.tmp"; $link="${conf['base']}/$fn0";
 if($verbose) { print "$fn0 updating.. "; $v="-v"; } else $v="";
 $cmd="${conf['wget']} -O\"$fntmp\" \"$link\";";
 $cmd.=" if [ ! -s \"$fntmp\" ]; then rm $v \"$fntmp\"; exit 1; fi;";
 $cmd.=" if cmp -s \"$fn\" \"$fntmp\"; then rm $v \"$fntmp\"; else mv $v \"$fntmp\" \"$fn\"; fi;";
 run($cmd);
}

########################
function get_installed() { global $conf;
 $l=explode("\n", `ls -L "${conf['base_installed']}/"`);
 #if(!empty($conf['pkgs_to_ignore'])) { $l=preg_grep($conf['pkgs_to_ignore'], $l, PREG_GREP_INVERT); }
 foreach($l as $fname) if(!empty($fname))
 { $p=name2arr($fname); $conf['pkgs_installed'][$p['name']]=$p; }
 print "get_installed(): ".count($conf['pkgs_installed'])." packages\n";
}

#################################
function get_packages_to_ignore() { global $conf;  $conf['pkgs_to_ignore']="";
 if(file_exists("packages_to_ignore"))
 {
  $conf['pkgs_to_ignore']=@file_get_contents("packages_to_ignore");
  $conf['pkgs_to_ignore']=explode("\n",$conf['pkgs_to_ignore']);
  foreach($conf['pkgs_to_ignore'] as $k => $v)
  { $v=trim($v);
   if(empty($v)) unset($conf['pkgs_to_ignore'][$k]); else $conf['pkgs_to_ignore'][$k]="^$v-";
  }
  $conf['pkgs_to_ignore']=implode("|",$conf['pkgs_to_ignore']);
  if(!empty($conf['pkgs_to_ignore']))
  {
   $conf['pkgs_to_ignore']="/".$conf['pkgs_to_ignore']."/";
   print "[ preg_ignored packages: ${conf['pkgs_to_ignore']} ]\n";
  }
 }
}
###################
function get_pkgs() { global $conf;  if(!@empty($conf['pkgs'])) return;
# $flts=filectime($fn);  $delta=time()-$flts; print "$fn0 (${delta}s)\n";
# { print "$fn0 updating.."; run("set -x; ${conf['wget']} \"${conf['base']}/$fn0\""); }
 $fn0="PACKAGES.TXT"; $fn="${conf['dl_path']}/_$fn0-${conf['release']}";
 if(@filesize($fn)<=0) { @unlink($fn); update_file($fn0,0,1); }
 $conf['pkgs']=Array();

 $gnl=0; $f=@fopen($fn, "r"); if(!$f) { print "can't open $fn\n"; $conf['pkgs']=Array(); return; }
 while(!feof($f)) { $a=fgets($f);
  if($gnl==1) { $gnl++; if(preg_match("@^([^:]+):.+?\((.+)\)\s*$@", $a, $m))
   { $conf['pkgs'][$pn]['desc'][0]=trim($m[2]); continue; }
   $gnl=0; continue;
  }
  if($gnl>1) { $gnl++; if(preg_match("@^([^:]+):\s*?(.*)$@", $a, $m))
   { $conf['pkgs'][$pn]['desc'][$gnl-2]=trim($m[2]); continue; }
   $gnl=0; continue;
  }

  if(preg_match("@^PACKAGE NAME:\s+(.+?)$@", $a, $m)) { $fname=trim($m[1]); $loca=$sizc=$sizu='';
   if(preg_match("@\.([a-z]+)$@", $fname, $m)) { $fext=$m[1];
    $fname=substr($fname,0,-(1+strlen($fext)));
   }

   $p1=explode("-", $fname); $p0=count($p1)-1;
   $rel=$p1[$p0]; unset($p1[$p0]);
   $arch=$p1[$p0-1]; unset($p1[$p0-1]);
   $ver=$p1[$p0-2]; unset($p1[$p0-2]);
   $pn=join("-", $p1);

   $conf['pkgs'][$pn]['fname']="$fname.$fext";  $conf['pkgs'][$pn]['name']=$pn;
   $conf['pkgs'][$pn]['ver']=$ver;
   $conf['pkgs'][$pn]['rel']=$rel;
   $conf['pkgs'][$pn]['arch']=$arch;
   continue; }
  if(preg_match("@^PACKAGE LOCATION:\s+(.+?)$@", $a, $m)) {
   $conf['pkgs'][$pn]['loca']=trim($m[1]);
   $conf['pkgs'][$pn]['dir']=preg_replace("@^.*/@", "", trim($m[1]));
   continue; }
  if(preg_match("@^PACKAGE SIZE \(compressed\):\s+(.+?)$@", $a, $m)) {
   if(preg_match("@^(\d+)\s+K$@", trim($m[1]), $m2)) $conf['pkgs'][$pn]['sizc']=$m2[1];
   continue; }
  if(preg_match("@^PACKAGE SIZE \(uncompressed\):\s+(.+?)$@", $a, $m)) {
   if(preg_match("@^(\d+)\s+K$@", trim($m[1]), $m2)) $conf['pkgs'][$pn]['sizu']=$m2[1];
   continue; }
  if(preg_match("@^PACKAGE DESCRIPTION:@", $a)) { $gnl=1; continue; }
  $gnl=0;
 }
 fclose($f); # print_r($conf['pkgs']); die();
 print "get_pkgs(): ".count($conf['pkgs'])." packages\n";
}
/*
#######################
function get_filelist_offf() { global $conf;
 if(!empty($conf['pkgs_filelist'])) { if(0)print "pkgs_filelist already populated\n"; return; }

 $fn="/tmp/FILE_LIST-${conf['release']}";
 $flts=filectime($fn);  $delta=time()-$flts;
 if(filesize($fn)<=0 || $delta>3600*4) {
  $link="${conf['base1']}/FILE_LIST";
  print "<div>getting <a href=\"$link\">FILE_LIST</a></div>";
  print `wget -q -O "$fn" "$link"`;
 }

 # -rw-r--r-- 1 root root 2326633 2003-03-13 19:00 ./y/bsd-games-2.13-i386-6.tgz
 foreach(preg_grep("@\.t[gx]z$@", file($fn)) as $k)
 {
  $tmp=trim(preg_replace("@ +@", " ", $k));
  $tmp=explode(" ", $tmp);
  $size=$tmp[4];
  $date=$tmp[5]." ".$tmp[6];
  list($trash,$dir,$fname)=explode("/",$tmp[7]);;
  $fext=substr($fname,-3);
  $fname=substr($fname,0,-4);
  if(!empty($fname))
  {
   $p=name2arr($fname);
   $conf['pkgs_filelist'][$p['name']]=$p;
   $conf['pkgs_filelist'][$p['name']]['dir']=$dir;
   $conf['pkgs_filelist'][$p['name']]['date']=$date;
   $conf['pkgs_filelist'][$p['name']]['size']=$size;
   $conf['pkgs_filelist'][$p['name']]['fname']=$fname;
   $conf['pkgs_filelist'][$p['name']]['fext']=$fext;
  }
 }
}
*/

########################
function get_checksums() { global $conf; if(!empty($conf['pkgs_md5'])) return;
 $fn0="CHECKSUMS.md5"; $fn="${conf['dl_path']}/_$fn0-${conf['release']}";
 if(@filesize($fn)<=0) { @unlink($fn); update_file($fn0,0,1); }
 $conf['pkgs_md5']=Array();
 foreach(explode("\n",file_get_contents($fn)) as $line) {
  if(!preg_match("@^([0-9a-f]+).+/(.+?)-([^-]+)-([^-]+)-([^-]+)\.([^\.]+)$@", $line, $m)) continue;
  if($m[6]=="txt"||$m[6]=="asc") continue;
  $conf['pkgs_md5'][$m[2]]=$m;
 }
 print "get_checksums(): ".count($conf['pkgs_md5'])." md5 sums\n";
}

##############################
function check_md5($fn, $sum0) {
 $a=@file_get_contents($fn); $sum=md5($a); unset($a);
 $sum0=strtolower($sum0);
#print "fn: $fn\nsum0: $sum0\n sum: $sum\n";
 if($sum0==$sum) return 1; else return 0;
}

##########################################################################################################
function cget_progress_cb($resource, $download_size = 0, $downloaded = 0, $upload_size = 0, $uploaded = 0) {
# $resource parameter was added in version 5.5.0 breaking backwards compatibility;
# if we are using PHP version lower than 5.5.0, we need to shift the arguments
# @see http://php.net/manual/en/function.curl-setopt.php#refsect1-function.curl-setopt-changelog
 if (version_compare(PHP_VERSION, '5.5.0') < 0) {
  $uploaded = $upload_size;
  $upload_size = $downloaded;
  $downloaded = $download_size;
  $download_size = $resource;
 }

# $perc=
 print "[$downloaded / $download size]                    \r";
 sleep(1); // just to see effect
 return 1;
 if($download_size > 0) echo $downloaded / $download_size  * 100;
 ob_flush(); flush();
}

###################################
function cget($link, $fn, $dl_path) { global $conf;
 if($link=="") { print "curl(): error: empty link\n"; return -1; }

# print "cget(): $link\n";

 if($dl_path=="") $dl_path=$conf['dl_path'];
 if($fn=="") $fn=basename($link);
 if($fn[0]!="/") $fn="$dl_path/$fn";
 $fp=fopen($fn, "w"); if(!$fp) { print "cget(): can't open output file $fn\n"; return -1; }

 $ch = curl_init();
 curl_setopt($ch,CURLOPT_URL,$link);
# curl_setopt($ch,CURLOPT_MAX_RECV_SPEED_LARGE,1024*105*4);
 $tmp=@$conf['curl_timeout']; if($tmp>0) curl_setopt($ch,CURLOPT_TIMEOUT,$tmp);
 #curl_setopt($ch,CURLOPT_HTTPHEADER,array('Accept-Encoding: gzip,deflate'));
 #curl_setopt($ch,CURLOPT_HTTPHEADER,array('Expect:'));
 curl_setopt($ch,CURLOPT_FOLLOWLOCATION,1);
 curl_setopt($ch,CURLOPT_MAXREDIRS,10);
 #curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,1);
 #curl_setopt($ch,CURLOPT_SSL_VERIFYHOST,2);
 #curl_setopt($ch,CURLOPT_SSL_CIPHER_LIST,);

 curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);
 curl_setopt($ch,CURLOPT_FILE,$fp);

 #curl_setopt($ch,CURLOPT_COOKIEJAR,$this->_cookieFileLocation);
 #curl_setopt($ch,CURLOPT_COOKIEFILE,$this->_cookieFileLocation);
 #curl_setopt($ch,CURLOPT_USERPWD, $this->auth_name.':'.$this->auth_pass);
 #curl_setopt($ch,CURLOPT_POST,1);
 #curl_setopt($ch,CURLOPT_POSTFIELDS,$this->_postFields);
 #curl_setopt($ch,CURLOPT_HEADER,1);
 #curl_setopt($ch,CURLOPT_NOBODY,1);
 #curl_setopt($ch,CURLOPT_BINARYTRANSFER,1);
 curl_setopt($ch,CURLOPT_USERAGENT, "kcst/${conf['kcst_version']} (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322)");
 #curl_setopt($ch,CURLOPT_REFERER, $link);

# curl_setopt($ch,CURLOPT_BUFFERSIZE,128);
# curl_setopt($ch,CURLOPT_PROGRESSFUNCTION,'cget_progress_cb'); # requires php 5.3.0+
 curl_setopt($ch,CURLOPT_NOPROGRESS,0);

 $buf=curl_exec($ch); $status=curl_getinfo($ch,CURLINFO_HTTP_CODE); $err=curl_error($ch); curl_close($ch);
 fclose($fp);
 if($status<200 || $status>=400) { print "cget(): error, status=$status, error=$err\n"; return -1; }
# $f=fopen($fn, "w"); if(!$f) { print "cget(): can't open output file $fn\n"; return -1; }
# fwrite($f, $buf); fclose($f);
 return 0;
}

############################
function pkg_download($name) { global $conf;
 get_pkgs(); get_checksums();
 if(substr($conf['base'],-1)=="/") $bs=""; else $bs="/";
 foreach(explode(" ",$name) as $pn) {
  $p=@$conf['pkgs'][$pn]; if(empty($p)) { print "package \"$pn\" not found\n"; continue; }
  $fn=$p['fname']; $fnf=$conf['dl_path']."/".$fn;

  if(file_exists($fnf)) {
   if(check_md5($fnf, $conf['pkgs_md5'][$pn][1])) {
    print "md5 OK ($fn), skipping download\n"; continue;
   } else { print "md5 differs on $fn. "; @unlink($fnf); }
  }

  print "get $fn ";
  if(0) run("${conf['wget']} \"${conf['base']}$bs${p['dir']}/$fn\" |grep -v URL:");
  else cget("${conf['base']}$bs${p['dir']}/$fn", "", "");

  if(!check_md5($fnf, $conf['pkgs_md5'][$pn][1]))
  { print " failed\n"; @unlink($fnf); return -1; } # else print "got $fs\n";
 }
 return 0;
}

###########################
function pkg_install($name) { global $conf;
 get_pkgs(); get_installed(); #$pi=$conf['pkgs_installed'];
 foreach(explode(" ",$name) as $pn) {
  $p=@$conf['pkgs'][$pn]; if(empty($p)) { print "package \"$pn\" not found\n"; continue; }

  $p0=@$conf['pkgs_installed'][$pn];
  if(empty($p0)) $v0="NEW"; else $v0="${p0['ver']}-${p0['rel']}-${p0['arch']}";
  $v1="${p['ver']}-${p['rel']}-${p['arch']}";
  $psk=round($p['sizu'],0);
  print "pkg_install $pn (${psk}k, $v0 => $v1)\n";

  $dfs=disk_free_space("/"); $dfsM=round($dfs/1024/1024,2);
  if($dfs<$p['sizu']*1024 || ($v0=="NEW" && $dfs<$p['sizu']*1024)) {
   print "short on disk space: \"/\" has only ${dfsM}MB available\n"; die();
  }

  $r=run("upgradepkg >>/tmp/kcst.log 2>&1 --install-new \"${conf['dl_path']}/${p['fname']}\"");
  if($r!=0) { print("there was an error ($r), check /tmp/kcst.log for full info, dumping 30 lines:\n\n");
   run("tail -n 30 /tmp/kcst.log"); die(); }

  remove_unneeded(0);
 }
}

#####################
function pkg_get($pn) { global $conf;
 if(empty($pn)) { print "pkg_get(): empty params\n"; return; }
 if(pkg_download($pn)<0) die("there was an error in download\n");
 pkg_install($pn);
}

##########################
function pkg_remove($name) { global $conf;
 get_installed(); $pi=$conf['pkgs_installed'];
 $rp=Array(); foreach(explode(" ",$name) as $a) {
  if(strpos($a, '*')===FALSE) {
   if(array_key_exists($a,$pi)) $rp[]=$a; else print "pkg '$a' not found, skipping\n";
  } else {
   foreach($pi as $pn=>$p) if(fnmatch($a, $pn)) $rp[]=$pn;
  }
 } natsort($rp);

 if(count($rp)==0) { print "no pkgs to remove\n"; return; }
 print "going to remove ".count($rp)." packages: ".join(" ", $rp)."\n";
 print "continue? (y/N) "; $ans=trim(fgets(STDIN)); if($ans!='y') { print "cancelled.\n"; die(); }

 foreach($rp as $pn) { print "pkg_remove $pn\n";
  run("removepkg \"$pn\" >>/tmp/kcst.log 2>&1");
 }
}

##########################
function pkg_search($name) { global $conf; 
 get_pkgs();  get_installed(); $pi=$conf['pkgs_installed'];

 print "\n### package names\n";
 $found=Array(); $plk=array_keys($conf['pkgs']); natsort($plk);
 foreach(preg_grep("/$name/", $plk) as $pn) { $p=$conf['pkgs'][$pn];
  $v=$p['ver'].'-'.$p['rel'];
  if(!@$pi[$pn]) $inst=''; else
  { $inst='INSTALLED'; $vi=$pi[$pn]['ver'].'-'.$pi[$pn]['rel']; if($v!=$vi) $inst.=":$vi"; }
  print "$pn - ".@$p['desc'][0]." ($v, ${p['dir']}, ${p['sizc']}k) $inst\n";
  $found[]=$pn;
 }

 print "\n### descriptions\n";
 foreach($conf['pkgs'] as $pn=>$p) if(!empty($p['desc'])) {
  if(preg_grep("/$name/i", $p['desc']) && !in_array($pn,$found))
  {
   $v=$p['ver'].'-'.$p['rel'];
   if(!@$pi[$pn]) $inst=''; else
   { $inst='INSTALLED'; $vi=$pi[$pn]['ver'].'-'.$pi[$pn]['rel']; if($v!=$vi) $inst.=":$vi"; }
   print "$pn - ".$p['desc'][0]." ($v, ${p['dir']}, ${p['sizc']}k) $inst\n";
   $found[]=$pn;
  }
 }
 print "\n### found ".count($found)." package(s)\n";
}

######################################
function pkg_search_file($name, $verb) { global $conf;  if($name=="") { show_help(); return; }
 $fn0="${conf['dl_path']}/MANIFEST.bz2";
 $fn="${conf['dl_path']}/_MANIFEST-${conf['release']}";
 if(@filesize($fn)<=0) {
  run("${conf['wget']} \"${conf['base']}/MANIFEST.bz2\" && bzip2 -dc \"$fn0\" > \"$fn\" && rm \"$fn0\"");
 }

 $f=@fopen($fn, "r"); if(!$f) { die("can't open $fn\n"); }
 $ret=Array();
 while(!feof($f)) { $a=fgets($f);
  if($a[0]=='|' && preg_match("@Package:\s+(.+)$@", $a, $m)) { $pn=$m[1]; continue; }
  if($a[0]=='-' && preg_match("@ ([^ ]+)$@", $a, $m)) { $b=trim("/".$m[1]);
//   if(strpos($b, $name)===FALSE) continue; else print "$pn: $b\n";
   if(preg_match("@$name@", $b)) { @$ret[$pn]++; if($verb)print "$pn: $b\n"; } else continue;
  }
 }
 fclose($f);
 return $ret;
}

###########################
function pkg_fixlibs($name) { global $conf;
 get_pkgs(); get_installed(); #$pi=$conf['pkgs_installed'];
 $i=0; $cwd=getcwd(); $libs=Array();
 if(empty($name)) $name="/bin /sbin /usr/bin /usr/sbin /lib /usr/lib /usr/libexec";
 foreach(explode(" ",$name) as $path) {
  if($path[0]!='/') $path="$cwd/$path";
  if(is_file($path)) $flist=$path; else
  {
   if(preg_match("@/lib@",$path)) $flist=`find '$path' -type f -name '*.so*'`;
   else $flist=`find '$path' -type f`;
  }
  print "[getting libs for files at $path] ";
  foreach(explode("\n", $flist) as $fi) if($fi) {
   $i++; if(1) print "."; else print "[$i: $fi]\n";
   $t=explode("\n",`ldd 2>/dev/null -u "$fi"|grep -vE '^(Unused|\s+not a dynamic)'|cut -f 2`);
   foreach($t as $n=>$l) if($l) @$libs[$l]++;
  }
  print "\n";
 } ksort($libs);

 if(count($libs)==0) { print "\n[no libs found (all static or not executable)]\n"; return; }

 print "\n[found ".count($libs)." lib(s), checking for missing ones]\n";
 $j=0; $vp="[a-zA-Z0-9_\.]+"; $to_install=Array();
 $pkgs=pkg_search_file( str_replace(".", "\.", join("|",array_keys($libs))), 0);
 foreach(array_keys($pkgs) as $pn0) if($pn0) { # ./d/gcc-7.3.0-i586-3.txz
  if(!preg_match("@/([^/]+)-$vp-$vp-$vp\.[a-z]+$@", $pn0, $m))
  { print "bad package name '$pn0'\n"; continue; }
  $pn=$m[1];
  if(@$conf['pkgs_installed'][$pn]) { if(0)print "INSTALLED $pn, skipping\n"; }
  else { $j++; print "install $pn\n"; $to_install[]=$pn; }
 }
 print "[found $j missing package(s)"; if($j==0) { print "]\n"; return; }
 print ": ".join(" ",$to_install)."]\ninstall? (y/N) ";
 $ans=trim(fgets(STDIN));
 if($ans!='y') { print "cancelled.\n"; return; }
 pkg_get(join(" ",$to_install));
}

############################
function pkg_find_upgrades() { global $conf;
 get_installed(); $pi=$conf['pkgs_installed'];
 get_packages_to_ignore();
 get_pkgs();
# get_filelist(); $pfl=$conf['pkgs_filelist'];
# updates: n-newest installed, a-available, A-available and minor ver changed, u-package unavailable

 $conf['pu']=Array();  $conf['pu_sa']=0;  $conf['pu_sA']=0;

 foreach($pi as $p) { $pn=$p['name']; $p1=@$conf['pkgs'][$pn];
  if(empty($p1)) { $conf['pu'][$pn]='u'; continue; }

  $v0=$p['ver'];  $v1=$p1['ver'];
  if($v0!=$v1) { $conf['pu'][$pn]='a'; $conf['pu_sa']+=$p1['sizc']; continue; }

  $v0=$p['ver']."-".$p['rel']."-".$p['arch'];
  $v1=$p1['ver']."-".$p1['rel']."-".$p1['arch'];
  if($v0!=$v1) { $conf['pu'][$pn]='A'; $conf['pu_sA']+=$p1['sizc']; continue; }

  $conf['pu'][$pn]='n';
 }
}

###############################
function pkg_upgrade($rels_too) { global $conf;
 if($rels_too) $conf['only_major_diff_in_upgrade']=0;
 pkg_find_upgrades();

 if($conf['only_major_diff_in_upgrade']) { $ps=$conf['pu_sa']; $pu=preg_grep('/^[a]$/', $conf['pu']); }
 else { $ps=$conf['pu_sa']+$conf['pu_sA']; $pu=preg_grep('/^[aA]$/', $conf['pu']); }

 $psM=round($ps/1024,2); $pcnt=count($pu); if($pcnt==0) { print "no upgrades found\n"; die(); }

 $ds=0; foreach($pu as $pn=>$sta) { $p=$conf['pkgs'][$pn];
#if(file_exists($conf['dl_path']."/".$p['fname'])) print ".";
#print_r($p);

  $ds+=@filesize($conf['dl_path']."/".$p['fname']);
 } $dsM=round($ds/1024/1024,2); $dsMr=$psM-$dsM;

 print "following packages will be upgraded: ".join(" ",array_keys($pu))."\n";
 print "$pcnt upgraded, need to get ${dsMr} MB of archives. ";

 # check available disk space
 $dfs=disk_free_space($conf['dl_path']); $dfsM=round($dfs/1024/1024,2);
 if($dfs<$ps*1024+1024*1024*10) {
  print "short on disk space: \"${conf['dl_path']}\" has only ${dfsM}MB available\n"; die(); }

 $dfs=disk_free_space("/"); $dfsM=round($dfs/1024/1024,2);
 if($dfs<1024*1024*50) {
  print "short on disk space: \"/\" has only ${dfsM}MB available\n"; die(); }

 print "continue? (y/N) "; $ans=trim(fgets(STDIN)); if($ans!='y') { print "cancelled.\n"; die(); }

 $essential="aaa_elflibs|glibc-solibs|pkgtools|sed|grep";
 # wget and it's reqs..
 $essential.="|wget|openssl-solibs|libunistring|libidn2|util-linux"; # in aaa_elflibs: pcre, zlib
 $ess_pkgs=join(" ", preg_grep("/^($essential)/",array_keys($pu)) );

 # first some essential packages
 if(!empty($ess_pkgs)) pkg_get($ess_pkgs);

 # then the rest
 pkg_get(join(" ", preg_grep("/^($essential)/",array_keys($pu),PREG_GREP_INVERT) ));
}

###################
function pkg_news() { global $conf;
 $fn0="ChangeLog.txt";
 $link=preg_replace("@/slackware/$@", "/$fn0", $conf['base']);
 $fn="${conf['dl_path']}/_$fn0-${conf['release']}";
 if(is_file($fn) && time()-@filectime($fn)>60*60) { print "removing old $fn0\n"; unlink($fn); }
 run("${conf['wget']} -O\"$fn\" \"$link\"");
 # $a=array_reverse(file($fn)); foreach($a as $l) { print $l; }
 print file_get_contents($fn);
}

########################
function pkg_list($filt) { global $conf;
 get_installed(); $pi=$conf['pkgs_installed'];
 $pkgs=array_keys($pi); if($filt!='') $pkgs=preg_grep("/$filt/i", $pkgs);
 foreach($pkgs as $pn) { print $pi[$pn]['fname']."\n"; }
}

############################
function remove_unneeded($v) { $cmd='';
 if($v==0) $cmd.='exec >>/tmp/kcst.log 2>&1;';
 $cmd.='cd /;';
 if($v>1) $cmd.='echo "Removing not-so-essential files..";';
 $cmd.='df |grep /$;';
 $cmd.='(cd usr/doc && rm -rf `ls |grep -ivE "^(cups)"` );';
 $cmd.='rm -rf usr/share/gtk-doc;';
 $cmd.='(cd usr/share/locale && rm -rf cs_* zh_* en_CA `ls |grep -vE "^(C|locale|en_US|remove_)"` );';
 $cmd.='(cd usr/lib/locale && rm -rf `ls |grep -vE "^(en_US|remove)"` );';
 $cmd.='(cd usr/include/c++ && rm -rf */*/bits/*/*.gch );';
 $cmd.='df|grep /$;';
 if($v>1) $cmd.='echo "..done.";';
# $cmd.='sync;';

# echo  " - usr/doc/* "; rm -rf usr/doc/*
# echo  " - usr/man/*/* "; rm -rf usr/man/*/*
 if($v>2) echo "$cmd\n";
 run($cmd);
}

####################
function httpd_way() { global $conf;
 $upg_sh=''; # $file_list_details=`ls -l /tmp/FILE_LIST`;
 $file_list_details=`ls -l "${conf['dl_path']}/PACKAGES.TXT"`;

 $f=fopen("/tmp/index-packages.html","w");
 fwrite($f, "<div><big>misc links:
   <a href=\"${conf['base1']}/../ChangeLog.txt\">../ChangeLog.txt</a>
 | <a href=\"${conf['base1']}/\">../ [base1]</a>
 | <a href=\"${conf['base']}/\">../ [base]</a>
</big></div>
<div><a href=\"file://${conf['dl_path']}/PACKAGES.TXT\">PACKAGES.TXT</a> details: $file_list_details<br>
installed packages list from: <b>${conf['base_installed']}</b></div>
");
 fwrite($f, format_list2());
 fwrite($f, "<hr><big># copy'n'paste upgrade</big>$upg_sh<br># end of list<hr>");
 fclose($f);

 print "\n<br>httpd_way done.\n";
}

########################
function format_list($l) { $ret="";
 $ret.="<table><tr><th>full name<th>pkg name<th>version<th>arch<th>rel";
 foreach($l as $name => $v) { $ret.="<tr>"."<td>".$v['fname']
  ."<td>".$v['name']."<td>".$v['ver']."<td>".$v['arch']."<td>".$v['rel']."\n";
 }  $ret.="</table>";  return $ret;
}

#######################
function format_list2() { global $conf;
 if(@$_GET['base_installed']>0) $conf['base_installeds'][0]=$_GET['base_installed'];
 $conf['base_installed']=$conf['base_installeds'][$conf['base_installeds'][0]];

 get_packages_to_ignore(); get_installed();
# get_filelist();
 get_pkgs();
# $pf=$conf['pkgs_filelist'];
 $pi=$conf['pkgs_installed']; #asort($pi);

 $ret="<style type=\"text/css\">
 TH,TD{text-align:left; vertical-align:top; padding:3px;}
 .b1px{border:1px solid black; padding:3px;}
 .h1px{height:1px; background:black;padding:0;}
 .upg1{font-size: 120%;}
 .upg2{font-size: 60%;}
 .right { text-align:right; }
 A { text-decoration: none; }
</style>";

 $ret.="<table class=b1px cellpadding=0 cellspacing=0><tr><th>pkg name <th>action <th>pkg date\n";
 foreach($pi as $name => $v)
 {
  $v1=$v['ver']."-".$v['arch']."-".$v['rel']; $newv='';
  $p2=@$conf['pkgs'][$name];
  if(!empty($p2))
  {
   $utype='n';
   $v2=$p2['ver']."-".$p2['arch']."-".$p2['rel'];
#if(!empty($conf['pkgs_to_ignore'])) { $l=preg_grep($conf['pkgs_to_ignore'], $l, PREG_GREP_INVERT); }
   if($v1 != $v2)
   {
    $link=$conf['base']."/".$p2['dir']."/".$p2['fname'];
    $utype='a';
    $newv =" =&gt; <b>$v2</b><br><small>"
    ." <a href=\"http://google.com/search?hl=en&btnG=Google+Search&q=download+".strtr($name,array(" "=>"+"))."\">src</a>"
    ." <a target=_blank href=\"$link.txt\">.txt</a>"
    ." <a target=_blank href=\"$link.asc\">.asc</a>"
    ." <a target=_blank href=\"$link.tgz\">.tgz ".$pf[$name]['size']." bytes</a>"
    ."</small>";
    if( !($conf['only_major_diff_in_upgrade'] && $v['ver']==$p2['ver'])
    && (empty($conf['pkgs_to_ignore']) || !preg_match($conf['pkgs_to_ignore'], $p2['name']."-")) )
    {
     $utype='A';
 $upg_sh.="<div class=upg1># \""
." [<span onclick=\"document.getElementById('hide_$name').innerHTML=''\">"
."<u>click to hide</u></span>]"
." $name-$v1 =&gt; $v2\"</div>\n"
."<div class=upg2 id=hide_$name>"
#."wget -nc $link.tgz; upgradepkg --install-new ".$p2['fname']."</div>\n"
."${conf['wget']} \"$link\"; upgradepkg --install-new ".$p2['fname']."</div>\n"
."";

     }
   }
  }
  else
  {
   $utype='u';
   $newv = " <small>
    <a href=\"http://google.com/search?hl=en&btnG=Google+Search&q=download+".strtr($name,array(" "=>"+"))."\">sources</a>
    or
    <a href=\"http://google.com/search?hl=en&btnG=Google+Search&q=%2bslackware+".strtr($name,array(" "=>"+"))."\">tgz</a>
    </small>\n";
  }
#  $ret0[$utype].="<tr><td colspan=3 class=h1px>";
$fname2=preg_replace("@\.[a-z]+$@", "", $v['fname']);
$pmodified="<small>".date("Y-m-d",filectime("/var/log/packages/$fname2"))."</small>";
  @$ret0[$utype].="\n<tr>"
."<td class=right>".$v['fname']
."<td>$newv"
."<td>$pmodified"
;
  #print($utype." ");
  @$utype_cnt[$utype]++;
 }

 print "\n";
 print "n:".strlen($ret0['n'])."\n";
 print "A:".strlen($ret0['A'])."\n";
 print "a:".strlen($ret0['a'])."\n";
 print "u:".strlen($ret0['u'])."\n";
 print "<div>updates: n-newest installed, a-available, A-available and version changed, u-package unavailable</div>\n";
 print_r($utype_cnt);

 $ret.="<tr><td colspan=4>[u] 
<span onClick=\"document.getElementById('pkg_u').style.display='block'\">show</span>
/ <span onClick=\"document.getElementById('pkg_u').style.display='none'\">hide</span>
<table id=pkg_u style=\"display:block\">".$ret0['u']."</table>";
# $ret.="<tr><td>".$ret0['n'];
# $ret.="<tr><td>".$ret0['A'];
 $ret.="<tr><td colspan=4>[a] 
<span onClick=\"document.getElementById('pkg_a').style.display='block'\">show</span>
/ <span onClick=\"document.getElementById('pkg_a').style.display='none'\">hide</span>
<table id=pkg_a style=\"display:none\">".$ret0['a']."</table>";
 $ret.="</table>";
 return $ret;
}

#########################
function name2arr($fname) { # wine-0.9.4-i486-S10.2-nodebug, wireless-tools-27-i486-2
 if(preg_match("@\.([a-z]+)$@", $fname, $m)) { $p['fext']=$m[1]; $fname=substr($fname,0,-4); }
 else { $p['fext']=''; }  $p['fname']=$fname;
 $p1=explode("-", $fname);  $p0=count($p1)-1;
 $p['rel']=$p1[$p0]; unset($p1[$p0]);
 $p['arch']=$p1[$p0-1]; unset($p1[$p0-1]);
 $p['ver']=$p1[$p0-2]; unset($p1[$p0-2]);
 $p['name']=join("-", $p1);
 return $p;
}


##################### slackware my configure
function mconf($argv) {
 if(@filesize("./configure")>0) $configure='./configure';
 else if(@filesize("../configure")>0) $configure='../configure';
 else die("no 'configure' in current or parent dir\n");

 $arch=@$argv[2]; if($arch=="help") { run("$configure --help 2>&1|tee z_conf_help.log"); return; }
 unset($argv[2]); if($arch=="") $arch="i586";

 $cmd="echo \"configuring for: $arch\"; echo -n \"$arch\" >z_arc;";
 $cmd.=' CC="gcc"; CXX="g++";';
# $cmd=' CC="distcc gcc"; CXX="distcc g++";';
# $cmd=' CC="/usr/local/bin/distcc/gcc"; CXX="/usr/local/bin/distcc/g++";';
 $cmd.=' export CHOST="i686-pc-linux-gnu";';
 $O="-s -Ofast -pipe -fomit-frame-pointer";
 switch($arch) {
#  case 'pm': $cmd.=' CFLAGS="'.$O.' -march=prescott -mtune=prescott -mmmx -msse -msse2 -msse3 -mfpmath=sse -ftree-vectorize -fno-strict-aliasing";'; break;
  case 'pm': $cmd.=' CFLAGS="'.$O.' -march=pentium-m -mtune=pentium-m";'; break;
  case 'p3': $cmd.=' CFLAGS="'.$O.' -march=pentium3 -mtune=pentium3 -fno-strict-aliasing -ftree-vectorize";'; break;
  case 'pmmx': $cmd.=' CFLAGS="'.$O.' -march=pentium-mmx -mtune=pentium-mmx -fno-strict-aliasing -fomit-frame-pointer";'; break;
#  case 'c7': $cmd.=' CFLAGS="'.$O.' -march=i686 -mtune=i686 -mmmx -msse";'; break;
  case 'c7': $cmd.=' CFLAGS="'.$O.' -march=c3-2 -mtune=c3-2 -mfpmath=sse,387 -msse2 -mmmx -msse";'; break;
  case 'i586': $cmd.=' CFLAGS="'.$O.' -march=i586 -mtune=i686";'; break;
  default: #die("usage: <arch> [params for configure]\narch choices: pm, p3, mmx, c7\n");
   $cmd.=' CFLAGS="'.$O.' -march=native -mtune=native";'; break;
 }
 $cmd.=' CXXFLAGS="${CFLAGS}";';
 $cmd.=' export CC CXX CHOST CFLAGS CXXFLAGS;';
 $cmd.=' echo -e "CC:\t$CC\nCHOST:\t$CHOST\nCFLAGS:\t$CFLAGS\nCXXFLAGS:\t$CXXFLAGS";';
 $cmd.=' time '.$configure.' 2>&1 --prefix=/usr --sysconfdir=/etc';
# if [ "$1" = "nodis" ]; then CONF=""; shift; fi
 $cmd.=' --disable-nls --disable-dependency-tracking';
 $cmd.=" ".join(" ", $argv);
 $cmd.=' |tee z_conf.log';
# print "$cmd\n";
 run($cmd);
}

##################### slackware my make
function mmake($argv) {
 $a=file_get_contents("/proc/cpuinfo");
 if(preg_match("@^processor@", $a, $m)) $jobs=floor(count($m)*1.5); else $jobs=1;
 $cmd='time make -j'.$jobs.' '.join(" ", $argv).' 2>z_mmake.log2 | tee z_mmake.log;';
 $cmd.=' if [ -s z_mmake.log2 ]; then echo -e "\n\n  STDERR:\n"; tail -n30 z_mmake.log2; fi;';
# print "$cmd\n";
 run($cmd);
}
#################### slackware make package
function mpkg($argv) { global $conf;
 $arch=@file_get_contents("z_arc");
 if(empty($arch)) { print "z_arc missing, use mconf before build?\n"; return -1; }
 $cwd=getcwd(); $pn=basename($cwd); $fn="${conf['sb_path']}/$pn-$arch-1${conf['sb_TAG']}.txz";
# $tmpp=$conf['sb_path']."/tmpbuild-$pn";
 $tmpp="/tmp/tmpbuild-$pn";
 $cmd="rm -rf \"$tmpp\"; mkdir -p \"$tmpp\" || exit 1;";
 $cmd.=" make DESTDIR=\"$tmpp\" install || exit 1; cd \"$tmpp\";";
 $cmd.=' find . -type f -wholename "*/man/*" -exec gzip -9v {} \; ;';
 $cmd.=' echo removing unneeded locales, gtk-docs..;';
 $cmd.=' (cd usr/share/locale && rm 2>/dev/null -rf cs_* zh_* en_CA `ls |grep -vE "(C|locale|en_US|pl|remove_)"` );';
 $cmd.=' (cd usr/lib/locale && rm 2>/dev/null -rf `ls |grep -vE "(pl_|en_US|remove)"` );';
 $cmd.=' rm 2>/dev/null -rf usr/share/gtk-doc;';
 $cmd.=" echo \"Press ENTER to create pkg $fn\"; read trash;";
 $cmd.=" makepkg -l y -c y \"$fn\";";
 $cmd.=" ls -l \"$fn\"; cd \"$cwd\"; rm -rf \"$tmpp\";";
# print "$cmd\n";
 run($cmd);
}


###################
function rnm($argv) { global $conf;
 $mre=@$argv[2]; $rpl=@$argv[3]; unset($argv[2]); unset($argv[3]);

 if(empty($mre) || in_array("-h",$argv)) {
  print("usage: rnm match replacement [-d] [-r] [-w] [-x]

	match - regexp to match
	replacement - guess?
	-d - also rename directories
	-r - run recursively
	-w - really rename (default is dry-run mode)
	-x - allow descending cross-dev mounts
");
  return;
 }

 $c=Array("writeok"=>false, "recurse"=>false, "recurse_limit"=>20, "dirstoo"=>false, "xdev"=>false);
 if(in_array("-w",$argv)) $c['writeok']=true;
 if(in_array("-r",$argv)) $c['recurse']=true;
 if(in_array("-d",$argv)) $c['dirstoo']=true;
 if(in_array("-x",$argv)) $c['xdev']=true;
 $cwd=getcwd();
 print "[cwd=$cwd, match=$mre, rplcmnt=$rpl, w=${c['writeok']} r=${c['recurse']} d=${c['dirstoo']} x=${c['xdev']}]\n";

 $did=0; $didok=0;
 $reb="@"; if(strpos($mre,$reb)!==false) {
  $reb="/"; if(strpos($mre,$reb)!==false) {
   $reb="#"; if(strpos($mre,$reb)!==false) {
    print "matching regexp contains @, / and #, can't continue\n"; return;
 }}}

 $st=stat($cwd); $c['st0']=$st[0];
 list($did,$didok)=rnm0($c,0,$cwd,"$reb$mre$reb",$rpl);
 print "[matches=$did, changes=$didok]\n";
}
#####################################
function rnm0($c,$rl,$path,$mre,$rpl) { $did=0; $didok=0;
 if(!$c['xdev']) { $st=stat($path); if($st[0]!=$c['st0']) { if(0)print "[not going xdev (${st[0]}!=${c['st0']})]\n"; return Array($did,$didok); } }
 $dh=opendir($path); if(!$dh) { print "[can't open $path]\n"; return Array($did,$didok); }
 while(($de=readdir($dh))) if($de!="" && $de!="." && $de!="..") {
  if($c['recurse'] && $rl<$c['recurse_limit'] && !is_link($de) && is_dir("$path/$de")) {
   list($did2,$didok2)=rnm0($c,$rl+1,"$path/$de",$mre,$rpl);
   $did+=$did2; $didok+=$didok2;
  }
  if(!$c['dirstoo'] && is_dir($de)) continue;
  $de2=preg_replace("$mre",$rpl,$de);
  if($de!=$de2 && $de2!='') { $did++; $fn="$path/$de"; $fn2="$path/$de2";
   if(file_exists($fn2)) $msg="[E:EXISTS]";
   else {
    if(!$c['writeok'])       $msg="[WOULDRNM]"; else
    { if(rename($fn,$fn2)) { $msg="[RENAMED_]"; $didok++; } else $msg="[E:FAILED]"; }
   }
   print "$msg [$path: $de => $de2]\n";
  }
 }
 closedir($dh);
 return Array($did,$didok);
}

########################
function grepfind($argv) {
 $re=@$argv[2]; unset($argv[2]); if(!array_key_exists(3,$argv)) { $argv[3]="."; }
 foreach($argv as $path) {
  $cmd='shopt -s dotglob; find "'.$path.'" | egrep -iE "'.$re.'";';
  run($cmd);
 }
}

###########################
function count_files($argv) {
 $path=@$argv[2]; if($path=="") $path=".";
 $cmd="shopt -s dotglob; cd \"$path\" && for each in * .; do";
 $cmd.=' if [ -d "$each" ]; then echo -n "'.$path.'/$each "; find "$each" -type f|wc -l; fi;';
 $cmd.=' done | sort -n -k2;';
 run($cmd);
}

### FUNCTIONS END ###
?>
